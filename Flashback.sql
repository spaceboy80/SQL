SELECT * FROM EMP
WHERE EXISTS (SELECT * FROM EMP WHERE ENAME = 'CARR');


SELECT e.ENAME, m.ENAME
FROM EMP m RIGHT OUTER JOIN EMP e on m.MGR = e.EMPNO;

--SELECT ENAME, SAL, '$200 RAISE' as "NOTE" FROM EMP;

--DROP TABLE EMPZ;

SELECT * FROM EMP;
SELECT * FROM DEPT;

CREATE TABLE DEMO1 (ID INT, NAME varchar(3), ST char(2) );

ALTER TABLE DEMO1
  DROP COLUMN ID;

INSERT INTO DEMO1 VALUES (1, 'XYZ', 'NY');
INSERT INTO DEMO1 VALUES (2, 'ABC', 'MA');
INSERT INTO DEMO1 VALUES (3, 'XXX', 'CA');
INSERT INTO DEMO1 VALUES (4, 'QUA', 'XX');
INSERT INTO DEMO1 VALUES (5, 'FIV', 'ZA');
COMMIT;

CREATE TABLE DEMO2 (ID INT, HILL varchar(4), ST char(2) );

INSERT INTO DEMO2 VALUES (1, 'VALL', 'NY');
INSERT INTO DEMO2 VALUES (2, 'VNFO', 'MA');
INSERT INTO DEMO2 VALUES (3, 'HAHA', 'CA');
INSERT INTO DEMO2 VALUES (4, 'FOUR', 'YY');
INSERT INTO DEMO2 VALUES (6, 'SIXX', 'ZA');
COMMIT;

/*
These two yield same results

SELECT a.NAME, b.HILL
FROM DEMO1 a join DEMO2 b USING (ID, ST);

SELECT NAME, HILL
FROM DEMO1 natural join DEMO2;

*/
SELECT a.NAME, b.HILL
FROM DEMO1 a JOIN DEMO2 b on a.ID = b.ID


UPDATE EMP
SET (SAL, COMM) = (SELECT SAL + 3000, NVL(COMM, 0) + 500 FROM EMP
WHERE ENAME = 'KING')
WHERE ENAME = 'KING';
COMMIT;

UPDATE EMP
SET COMM = 
CASE
WHEN JOB = 'SALESMAN' THEN .10 * SAL--(SELECT DISTINCT .10 * SAL FROM EMP WHERE JOB = 'SALESMAN')
WHEN JOB = 'MANAGER' THEN  .25 * SAL--(SELECT .25 * SAL FROM EMP WHERE JOB = 'MANAGER') 
WHEN JOB = 'PRESIDENT' THEN  .25 * SAL--(SELECT DISTINCT COMM FROM EMP WHERE JOB = 'PRESIDENT')
ELSE NULL
END;

UPDATE EMP
SET SAL = 8000
WHERE JOB = 'PRESIDENT';
COMMIT;

SELECT * FROM EMP;

SELECT ENAME, NVL (TO_CHAR(1.1 * COMM), 'No Comm') AS INCREASE
FROM EMP;

SELECT ENAME, TO_CHAR ( NVL(1.1 * COMM, 'No Comm') ) as increase
FROM EMP;


SELECT * FROM EMP;

DELETE FROM EMPZ
WHERE (SELECT DEPTNO FROM DEPT WHERE DEPTNO = 10);
COMMIT;

SELECT * FROM EMP
WHERE UPPER(ENAME) = 'SMITH'
order by 2;

ALTER TABLE EMPZ
  MODIFY ENAME CONSTRAINT NN_ENAME NOT NULL;
--ADD CONSTRAINT NN_ENAME NOT NULL (ENAME);


INSERT INTO EMP (ENAME, JOB) VALUES ('smith', 'CLERK');
COMMIT;

SELECT ENAME, SAL || ' + ' || COMM || ' IN DEPT ' || DEPTNO as PIPES, CONCAT(SAL || ' + ' || COMM || ' IN DEPT ', DEPTNO) as CONC   FROM EMP
WHERE COMM IS NOT NULL

CREATE TABLE empZ
  (emp_no NUMBER(2) CONSTRAINT emp_emp_no_pk PRIMARY KEY,
  ename VARCHAR2(15),
  salary NUMBER (8,2),
  mgr_no NUMBER(2) CONSTRAINT emp_mgr_fk REFERENCES empZ(emp_no));
  
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPZ';

ALTER TABLE empZ
DISABLE CONSTRAINT emp_emp_no_pk CASCADE;

ALTER TABLE empZ
ENABLE CONSTRAINT emp_emp_no_pk;

ALTER TABLE empZ
  ENABLE PRIMARY KEY;


WITH dept_avg as (SELECT DEPTNO, AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO)
SELECT e.ENAME, e.JOB, CASE WHEN SAL + NVL(COMM, 0) > AVGSAL THEN CONCAT('+',TO_CHAR((SAL + NVL(COMM, 0) - AVGSAL), 9999))
                        WHEN SAL + NVL(COMM, 0) < AVGSAL THEN TO_CHAR((SAL + NVL(COMM, 0) - AVGSAL), 9999)
                        ELSE TO_CHAR(AVGSAL)
                      END AS DIFF
FROM EMP e JOIN dept_avg da on e.DEPTNO = da.DEPTNO

CREATE TABLE EMP2 AS SELECT * FROM EMP;



ALTER TABLE EMP2
  MODIFY EMPNO CONSTRAINT pk_EMP2 PRIMARY KEY;
  
CREATE UNIQUE INDEX IDX_EMPNO on EMP2(EMPNO);

SELECT * FROM EMP2;

DESC EMP2
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP2'; 
SELECT * FROM USER_INDEXES WHERE TABLE_NAME = 'EMP2';

--TRUNCATE TABLE EMP2;
DROP TABLE EMP2; --INDEXES AND CONSTRAINTS GET DROPPED

/*
GROUP BY ignores nulls except for count(*)
GROUPING identifies super aggregates
GROUPING_ID returns a number corresponding to grouping bit vector associated with a row
*/

--FLASHBACK QUERIES
--ROW LEVEL
SELECT COUNT(*) FROM EMP
       AS OF timestamp (sysdate - 500/1440);

SELECT ROUTEID, ROUTENAME, ORA_ROWSCN, SCN_TO_TIMESTAMP(ORA_ROWSCN) as "Back in TIme" FROM ROUTES;
--TABLE LEVEL
SELECT ORIGINAL_NAME, OPERATION, DROPTIME FROM RECYCLEBIN;

flashback table EMP to timestamp (sysdate - 500/1440);--DROP;

SELECT * FROM VEMPDEPT;
SELECT * FROM EMPZ;
SELECT * FROM DEPT;

INSERT INTO VEMPDEPT (NAME, JOB, DEPTNO) values ('OBAMA', 'PRESIDENT', 20 );

SELECT * FROM ALL_CONSTRAINTS
WHERE OWNER = 'SCOTT';
--INVISIBLE COLUMNS need to be called explicitly
--Views can modify the underlying table when constraint values 
--are taken into consideration
CREATE OR REPLACE VIEW VEMPDEPT2 (NAME, JOB, SALARY, DEPTNO, DNAME, x INVISIBLE)
AS
SELECT E.ENAME,E.JOB, E.SAL + NVL(E.COMM, 0) as SALARY, E.DEPTNO, D.DNAME, D.x
FROM EMP E JOIN DEPT D on E.DEPTNO = D.DEPTNO
where E.SAL > 2000
WITH CHECK OPTION;

CREATE OR REPLACE VIEW VEMPDEPT2
AS
SELECT ENAME,JOB, SAL
FROM EMP 
where SAL > 2000
WITH CHECK OPTION;

SELECT * FROM VEMPDEPT2;

INSERT INTO VEMPDEPT2 (ENAME, JOB, SAL) VALUES ('PARKER', 'MANAGER', 2500);

SELECT EMPNO, x FROM VEMPDEPT;

CREATE OR REPLACE VIEW vDEPT
AS
SELECT * FROM DEPT;

ALTER TABLE DEPT
  ADD x varchar(5) INVISIBLE;
  
SELECT DEPTNO, x FROM DEPT;
SELECT DEPTNO, x FROM VDEPT;

SELECT MAX(EMPNO) FROM EMP;

CREATE SEQUENCE EMPSEQ 
START WITH 7934 INCREMENT BY 1;

--New to Oracle 12, placing sequences in default
ALTER TABLE EMP
  MODIFY EMPNO DEFAULT EMPSEQ.nextval;
  
  SELECT EMPSEQ.currval from dual;
  
  SELECT * from USER_SEQUENCES;

SELECT * FROM EMP;
INSERT INTO EMP (ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES ('CUBRICK', 'CLERK', 7839, '01-JAN-12', 500, 0, 10);


SELECT * FROM EMPZ;

SELECT ENAME 

CREATE TABLE STRINGTEST (id int, word1 char(5), word2 varchar(5), word3 varchar2(5) );

INSERT INTO STRINGTEST VALUES (3, 'ABC', 'ABC' , 'ABC');
INSERT INTO STRINGTEST VALUES (4, 'ABC', 'ABC', 'ABC');

SELECT LENGTH(word1), LENGTH(word2), LENGTH(word3) FROM STRINGTEST
WHERE word1 = 'ABC';

CREATE TABLE STRINGTEST2 (id int, word1 varchar(1), word2 varchar2(1), TESTL long, TESTl2 long);
DROP TABLE STRINGTEST2;

SELECT TO_DATE('02-04-1999', 'MM-DD-YYYY') - 36 FROM DUAL;


CREATE TABLE DATECHECKER (id int, date1 date, date2 timestamp, date3 INTERVAL DAY (5) TO SECOND (3));
CREATE TABLE DATECHECKER2 (dateme INTERVAL DAY (5) TO SECOND (3));

INSERT INTO DATECHECKER2 values ( interval '3' day)
SELECT * FROM DATECHECKER2;
COMMIT;


INSERT INTO DATECHECKER VALUES (1, SYSDATE, SYSDATE, NULL);


SELECT * FROM DATECHECKER;

SELECT 'Today is ' || TO_CHAR(SYSDATE, 'DAY') FROM DUAL;
SELECT TO_CHAR (SYSDATE, ' "Today is " DAY ') FROM DUAL;


SELECT TO_CHAR(NEXT_DAY(LAST_DAY(SYSDATE), 'MON'),'dd "is the first Monday for" fmmonth rrrr')
FROM DUAL;

SELECT LAST_DAY(SYSDATE) FROM DUAL;
SELECT NEXT_DAY(LAST_DAY(SYSDATE), 'TUE') FROM DUAL

/*

INDEXES: 
      UNIQUE (high cardinality), BITMAP (Low cardinality) , Function based (by expression) : execute permission needed
        can be associated with constraint
          with INVISIBLE ignored by optimizer

ALTER INDEX index MONITORING USAGE; determine if needed

Mulitple indexes with different types of indexes can be applied to same column, though others have to be invisible
USER_INDEXES used to view details

MULTI TABLE INSERT

Based on condition
INSERT FIRST
  WHEN (x > y ) THEN INTO  dest_table (col1, col2, col3) VALUES (col1, col2, col3)...
SELECT * FROM source_table

No condition
INSERT ALL
  INTO dest_table (col1, col2, col3) VALUES (col1, col2, col3)
SELECT * FROM source_table


MERGE:

    MERGE [hint] INTO [schema .]table [t_alias]
    USING [[schema .]table | view | subquery] t_alias
    ON ( condition ) [merge_update_clause | merge_insert_clause]

    merge_update_clause:

      WHEN MATCHED THEN UPDATE SET [<column> = [<expr>|DEFAULT][,]]<where_clause>
      DELETE <where_clause>

    merge_insert_clause:

      WHEN NOT MATCHED THEN INSERT ( <column> [,])
      VALUES (<expr>|DEFAULT[,])
      <where_clause>
*/